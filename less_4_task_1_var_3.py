"""
Задача 1.
Проанализировать скорость и сложность одного любого алгоритма
из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
● выбрать хорошую задачу, которую имеет смысл оценивать
(укажите в комментарии какую задачу вы взяли),
● написать 3 варианта кода (один у вас уже есть),
● проанализировать 3 варианта и выбрать оптимальный,
● результаты анализа вставить в виде комментариев в файл с кодом
(не забудьте указать, для каких N вы проводили замеры),
● написать общий вывод: какой из трёх вариантов лучше и почему.
"""

"""
Для разбора беру задачу 4 из ПЗ к уроку 3: "Определить, какое число в массиве встречается чаще всего."
Рассматриваю 3 вариант, каждый в отдельном файле.
"""

# Вариант 3 - с использованием словаря для хранения встречающихся чисел и счётчиков

import random
import timeit
import cProfile

MIN_ITEM = 0
MAX_ITEM = 5
SIZE_1 = 100
SIZE_2 = 200
SIZE_3 = 300
SIZE_4 = 400
SIZE_5 = 500
SIZE_6 = 600
arr_1 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_1)]
arr_2 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_2)]
arr_3 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_3)]
arr_4 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_4)]
arr_5 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_5)]
arr_6 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_6)]

def func_3(arr):
    count_dict = {}
    frequency = 1
    num = None
    for item in arr:
        if item in count_dict:
            count_dict[item] += 1
        else:
            count_dict[item] = 1
        if count_dict[item] > frequency:
            frequency = count_dict[item]
            num = item
    if num is None:
        return 'Все элементы уникальны'
    else:
        return num, frequency

print(timeit.timeit('func_3(arr_1)', number=5000, globals=globals()))  # 0.1381547
print(timeit.timeit('func_3(arr_2)', number=5000, globals=globals()))  # 0.3262421
print(timeit.timeit('func_3(arr_3)', number=5000, globals=globals()))  # 0.41620800000000013
print(timeit.timeit('func_3(arr_4)', number=5000, globals=globals()))  # 0.50044
print(timeit.timeit('func_3(arr_5)', number=5000, globals=globals()))  # 0.5997455999999999
print(timeit.timeit('func_3(arr_6)', number=5000, globals=globals()))  # 0.8436414999999999

SIZE_7 = 1_000_000
arr_7 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_7)]
cProfile.run('func_3(arr_7)')
#       4 function calls in 0.306 seconds
#
# Ordered by: standard name
#
# ncalls  tottime  percall  cumtime  percall filename:lineno(function)
#      1    0.000    0.000    0.306    0.306 <string>:1(<module>)
#      1    0.306    0.306    0.306    0.306 test3.py:25(func_3)
#      1    0.000    0.000    0.306    0.306 {built-in method builtins.exec}
#      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

"""
Число измерений в timeit оставил такое же, как в варианте 2 - 5000.
Для cProfile также оставил размер массива 1_000_000, как в варианте 2.

Выводы:
1. В функции func_3(arr) только один цикл, все элементы массива arr
просматриваются за 1 проход, поэтому функция func_3(arr) имеет линейную
асимптотику - O(n) - при увеличении длины массива в N раз время увеличивается
в N раз.
Это подтверждается результатами измерений.
Надо взять расчётное время 0.13 при N = 100:
(Число слева - это N)
100 | 0.13 * 1 = 0.13 (результат измерений: 0.1381547)
200 | 0.13 * 2 = 0.26 (результат измерений: 0.3262421)
300 | 0.13 * 3 = 0.49 (результат измерений: 0.41620800000000013)
400 | 0.13 * 4 = 0.52 (результат измерений: 0.50044)
500 | 0.13 * 5 = 0.65 (результат измерений: 0.5997455999999999)
600 | 0.13 * 6 = 0.78 (результат измерений: 0.8436414999999999)

Как видим, расчётное время близко к результатам timeit.

2. В функции func_3(arr) только один цикл, а в функции func_2(arr) -
два цикла (один вложен в другой), и внешний цикл выполняется 6 раз,
так как он выполняется по множеству set(arr), а в тестах MIN_ITEM = 0
и MAX_ITEM = 5 и размеры массивов arr большие, поэтому предполагаем, что
все числа из диапазона 0-5 должны встретиться в них хотя бы один раз.
Поэтому теоретически можно предположить, что вариант 3 должен работать быстрее,
чем вариант 2, в 6 раз при тех же условиях.
Но, как видим, он работает только примерно в 1.3-1.6 раз быстрее,
чем вариант 2, если поделить время из варианта 2 на время из варианта 1
из строк с одинаковыми N, напр.
0.192 / 0.138 = 1.391
0.437 / 0.326 = 1.340
0.607 / 0.416 = 1.459
0.809 / 0.500 = 1.618

То, что вариант 3 быстрее варианта 2 не в 6 раз, а только в 1.3-1.6 раз,
скорее всего объясняется работой со словарём в варианте 3.

3. По результатам cProfile можно сделать вывод, что функция func_3(arr)
запускается 1 раз.
Сравнив время работы с временем из варианта 2, можно увидеть такой же результат
относительно скорости работы, как и выше - вариант 3 быстрее варианта 2
примерно в 1,5 раза:
0.457 / 0.306 = 1.49

То есть график функции func_3(arr) будет идти ниже графика функции func_2(arr).

Таким образом, вариант 3 - самый лучший - имеет линейную зависимость,
работает быстрее варианта 2.
Вариант 2 - неплохой, имеет линейную зависимость, но работает в 1.3 - 1.6 раз
медленнее варианта 3.
Вариант 1 - совсем плохой, имеет квадратичную зависимость.
"""
