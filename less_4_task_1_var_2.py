"""
Задача 1.
Проанализировать скорость и сложность одного любого алгоритма
из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
● выбрать хорошую задачу, которую имеет смысл оценивать
(укажите в комментарии какую задачу вы взяли),
● написать 3 варианта кода (один у вас уже есть),
● проанализировать 3 варианта и выбрать оптимальный,
● результаты анализа вставить в виде комментариев в файл с кодом
(не забудьте указать, для каких N вы проводили замеры),
● написать общий вывод: какой из трёх вариантов лучше и почему.
"""

"""
Для разбора беру задачу 4 из ПЗ к уроку 3: "Определить, какое число в массиве встречается чаще всего."
Рассматриваю 3 вариант, каждый в отдельном файле.
"""

# Вариант 2 - с использованием выделения уникальных элементов массива arr
# через преобразования во вножество

import random
import timeit
import cProfile

MIN_ITEM = 0
MAX_ITEM = 5
SIZE_1 = 100
SIZE_2 = 200
SIZE_3 = 300
SIZE_4 = 400
SIZE_5 = 500
SIZE_6 = 600
arr_1 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_1)]
arr_2 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_2)]
arr_3 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_3)]
arr_4 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_4)]
arr_5 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_5)]
arr_6 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_6)]

# Создаем второй массив из уникальных элементов первого массива
def list_to_set(arr):
    return set(arr)

def func_2(arr):
    # temp_set = set(arr)  # Создаем второй массив из уникальных элементов первого массива
    temp_set = list_to_set(arr)
    count_max = 0
    # Теперь перебор кандитов на макс.число идёт из множества temp_set, которое гораздо меньше массива arr
    for item_1 in temp_set:
        count = 0
        for item_2 in arr:
            if item_1 == item_2:
                count += 1
        if count > count_max:
            num = item_1
            count_max = count
    return num, count_max

print(timeit.timeit('func_2(arr_1)', number=5000, globals=globals()))  # 0.19214640000000002
print(timeit.timeit('func_2(arr_2)', number=5000, globals=globals()))  # 0.4370908
print(timeit.timeit('func_2(arr_3)', number=5000, globals=globals()))  # 0.6066793
print(timeit.timeit('func_2(arr_4)', number=5000, globals=globals()))  # 0.8086211000000001
print(timeit.timeit('func_2(arr_5)', number=5000, globals=globals()))  # 1.0046808
print(timeit.timeit('func_2(arr_6)', number=5000, globals=globals()))  # 1.2000299

SIZE_7 = 1_000_000
arr_7 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_7)]
cProfile.run('func_2(arr_7)')
#       5 function calls in 0.457 seconds
#
# Ordered by: standard name
#
# ncalls  tottime  percall  cumtime  percall filename:lineno(function)
#      1    0.000    0.000    0.457    0.457 <string>:1(<module>)
#      1    0.021    0.021    0.021    0.021 test2.py:23(list_to_set)
#      1    0.435    0.435    0.457    0.457 test2.py:26(func_2)
#      1    0.000    0.000    0.457    0.457 {built-in method builtins.exec}
#      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

"""
Вариант 2 работает быстрее, чем вариант 1, поэтому увеличил число вызовов
в timeit с 1000 до 5000, чтобы время было более чётко видно.
Для cProfile увеличил размер массива до 1_000_000 с той же целью.

Выводы:
1. В функции func_2(arr) 2 цикла, один вложен в другой, но первый цикл
выполняется по постоянному числу элементов, так как диапазон уникальных
значений ограничен константами MIN_ITEM и MAX_ITEM, поэтому первый цикл
не влияет на асимптотику. Влияет только второй цикл - в нём перебираются
все элементы массива arr.
Таким образом, функция func_2(arr) имеет линейную асимптотику - O(n) -
при увеличении длины массива в N раз время увеличивается в N раз.
Это подтверждается результатами измерений.
Расчётное время, основываясь на 0.19 при N = 100:
(Число слева - это N)
100 | 0.19
200 | 0.19 * 2 = 0.38 (результат измерений: 0.4370908)
300 | 0.19 * 3 = 0.57 (результат измерений: 0.6066793)
400 | 0.19 * 4 = 0.76 (результат измерений: 0.8086211000000001)
500 | 0.19 * 5 = 0.95 (результат измерений: 1.0046808)
600 | 0.19 * 6 = 1.14 (результат измерений: 1.2000299)

В данном случае, если принять, что время при N = 100 будет 0.2 секунды,
а не 0.19, то результаты измерений будут совпадать с расчётным более точно.

2. По результатам cProfile можно сделать вывод, что функция func_2(arr)
запускается 1 раз, и функция list_to_set(arr) также запускается 1 раз.
Работа функции list_to_set(arr) очень несущественно влияет на конечный
результат - в данном тесте её время работы примерно в 21 раз меньше,
чем время работы функции func_2(arr).
"""
